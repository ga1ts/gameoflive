https://gitlab.com/school218063421/cprojects/school21/-/tree/main/P02D13-1/src?ref_type=heads
#include <ncurses.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define ROWS 25
#define COLS 80

void print_board(int board[ROWS][COLS]);
void update_board(int board[ROWS][COLS]);
int neighbors(int i, int j, int board[ROWS][COLS]);
void update_cell(int new_board[ROWS][COLS], int board[ROWS][COLS]);
void read_file(int matrix[ROWS][COLS]);
void assignment(int matrix[ROWS][COLS], int board[ROWS][COLS]);
int checking_board(int board[ROWS][COLS]);
void pressed_key(int *delay);

int main() {
    int board[ROWS][COLS];
    int condition[ROWS][COLS];
    int delay = 100000;

    // Инициализация ncurses
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0);
    timeout(0);

    read_file(condition);
    assignment(condition, board);

    do {
        clear();
        print_board(board);
        refresh();
        pressed_key(&delay);
        update_board(board);
        usleep(delay);
    } while (checking_board(board) != 1);

    endwin();
    printf("Game Over!\n");
    return 0;
}

void read_file(int matrix[ROWS][COLS]) {
    int nfile;
    FILE *file = NULL;

    printw("Enter the initial configuration number (1-5):\n");
    printw("1. Ship\n2. Pattern 2\n3. Pattern 3\n4. Pattern 4\n5. Pattern 5\n");
    refresh();
    scanw("%d", &nfile);

    switch(nfile) {
        case 1: file = fopen("1.txt", "r"); break;
        case 2: file = fopen("2.txt", "r"); break;
        case 3: file = fopen("3.txt", "r"); break;
        case 4: file = fopen("4.txt", "r"); break;
        case 5: file = fopen("5.txt", "r"); break;
        default:
            endwin();
            fprintf(stderr, "Invalid input! Use numbers 1-5.\n");
            exit(1);
    }

    if (!file) {
        endwin();
        fprintf(stderr, "Error opening file!\n");
        exit(1);
    }

    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            fscanf(file, "%d", &matrix[i][j]);
        }
    }
    fclose(file);
}

void assignment(int matrix[ROWS][COLS], int board[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            board[i][j] = matrix[i][j];
        }
    }
}

int checking_board(int board[ROWS][COLS]) {
    static int prev_board[ROWS][COLS];
    static int count = 0;
    int same = 1;

    // Проверка на стабильность
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (prev_board[i][j] != board[i][j]) {
                same = 0;
                break;
            }
        }
    }

    // Сохраняем текущее состояние
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            prev_board[i][j] = board[i][j];
        }
    }

    return (same && ++count > 3) ? 1 : 0;
}

void print_board(int board[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            printw("%c", board[i][j] ? 'O' : '.');
        }
        printw("\n");
    }
}

int neighbors(int i, int j, int board[ROWS][COLS]) {
    int count = 0;
    for (int dx = -1; dx <= 1; dx++) {
        for (int dy = -1; dy <= 1; dy++) {
            if (dx == 0 && dy == 0) continue;
            
            int x = (i + dx + ROWS) % ROWS;
            int y = (j + dy + COLS) % COLS;
            
            count += board[x][y];
        }
    }
    return count;
}

void update_cell(int new_board[ROWS][COLS], int board[ROWS][COLS]) {
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            int n = neighbors(i, j, board);
            new_board[i][j] = (n == 3 || (board[i][j] && n == 2)) ? 1 : 0;
        }
    }
}

void update_board(int board[ROWS][COLS]) {
    int new_board[ROWS][COLS];
    update_cell(new_board, board);
    assignment(new_board, board);
}

void pressed_key(int *delay) {
    int ch = getch();
    if (ch != ERR) {
        switch(ch) {
            case '+': case '=':
                *delay = (*delay > 50000) ? *delay - 50000 : 10000;
                break;
            case '-': case '_':
                *delay += 50000;
                break;
            case 'q': case 'Q':
                endwin();
                exit(0);
        }
    }
}
